---
title: 'Default, simple and quick use usage 3: many to many comparions'
author: "Luis Ospina-Forero"
date: "23/06/2020"
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{ManyToMany}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  ---
  
  ```{r, include = FALSE}
  knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
  )
  ```
  
  # Introduction
  
  In some situations there is a need to compare multiple graphs among each other. For such situations, the `netdist` package contains some initial shortcut functions that perform such calculation and may incorporate parallel processing. 
  
  This Vignette follows similar examples as ["Default, simple and quick use usage 1: pairwise comparisons"](default_pairwise_usage.html) but shows the default usage of the shortcut functions for many-to-many comparisons.
  
  # Load required packages/libraries
  ```{r, packages, message= FALSE}
  # Load packages/libraries
library("netdist")
library("igraph")
library("pheatmap")
```

# Compare two networks via NetEmd.

## Comparing two graphs with NetEmd via subgraph counts.
```{r, netemd,fig.align='center'}
# Create lattice networks
gLat_1 <- graph.lattice(c(8,8)) 
gLat_2 <- graph.lattice(c(44,44))  
gRing_1 <- make_ring(8^2) 
gRing_2 <- make_ring(44^2)
gTree_1 <- make_tree(n = 8^2) 
gTree_2 <- make_ring(n = 44^2)


#Providing a matrix of network features
counts_1= count_orbits_per_node(graph = gLat_1,max_graphlet_size = 5)
counts_2= count_orbits_per_node(graph = gLat_2,max_graphlet_size = 5)

netemd_one_to_one(dhists_1=counts_1, dhists_2=counts_2)

#Providing the network features as lists of dhist objects
dhists_1<- graph_features_to_histograms(counts_1)
dhists_2<- graph_features_to_histograms(counts_2)

netemd_one_to_one(dhists_1=dhists_1, dhists_2=dhists_2)
```

## Comparing two graphs with NetEmd via their Laplacian spectrum.
```{r, netemdEigen,fig.align='center'}
# Networks
gLat_1 <- graph.lattice(c(8,8)) 
gLat_2 <- graph.lattice(c(44,44))  

#Laplacian
Lapg_1 <- igraph::laplacian_matrix(graph = gLat_1,normalized = FALSE,sparse = FALSE)
Lapg_2 <- igraph::laplacian_matrix(graph = gLat_2,normalized = FALSE,sparse = FALSE)

#Normalized Laplacian
NLapg_1 <- igraph::laplacian_matrix(graph = gLat_1,normalized = TRUE,sparse = FALSE)
NLapg_2 <- igraph::laplacian_matrix(graph = gLat_2,normalized = TRUE,sparse = FALSE)

# Providing a matrix of network features (e.g. Spectra). Spectra (This may take a couple of minutes).
spec_1 <- cbind(L.Spectra= eigen(Lapg_1)$values, NL.Spectra= eigen(NLapg_1)$values) 
spec_2 <- cbind(L.Spectra= eigen(Lapg_2)$values, NL.Spectra= eigen(NLapg_2)$values) 

netemd_one_to_one(dhists_1 = spec_1,dhists_2 = spec_2, smoothing_window_width = 0)


# Providing pre-computed dhist objects from network features
dhists_1<- graph_features_to_histograms(spec_1)
dhists_2<- graph_features_to_histograms(spec_2)

netemd_one_to_one(dhists_1=dhists_1, dhists_2=dhists_2, smoothing_window_width = 0)
```
-------------------------

# Compare two networks via Netdis and its variants.

## Using netdis with a gold-standard graph to obtain $E_w$.
The selection of a gold-standard graph as a substitute for $E_w$ could be done when such graph is known to be a good proxy for $E_w$, or alternatively as a good reference point for the comparison. This option will focus on detecting discrepancies between the networks relative to the ego-network structure of the reference network / gold-standard (summarized in $E_w$).

```{r,netdisgoldstand,fig.align='center'}
# Create lattice, Ring and Tree like networks of sizes 8^2 and 44^2.
set.seed(3171)
gLat_1 <- graph.lattice(c(8,8)) 
gLat_2 <- graph.lattice(c(44,44))  
gRing_1 <- make_ring(8^2) 
gRing_2 <- make_ring(44^2)
gTree_1 <- make_tree(n = 8^2,children = 3) 
gTree_2 <- make_tree(n = 44^2,children = 3)

# Create a random graph to be used as a gold-standard
gst_1 <- graph.star(8^2,)
gst_2 <- graph.star(44^2)


# Netdis using the goldstd_1 graph as gold-standard reference point
glist <- list(Lat_1=gLat_1, Lat_2=gLat_2, Ring_1=gRing_1, Ring_2=gRing_1, Tree_1=gTree_1, Tree_2=gTree_2)

netdis_mat_gst1 <- netdis_many_to_many(graphs = glist, ref_graph = gst_1)
netdis_mat_gst2 <- netdis_many_to_many(graphs = glist, ref_graph = gst_2)

netdis_mat_gst1

netdis_mat_gst2
```

```{r,netdisgoldstandPLOT,fig.align='center'}
# Creating matrices to plot the the comparison
mat_gst1 <- matrix(nrow=6,ncol=6,0)
mat_gst2 <- matrix(nrow=6,ncol=6,0)
vnames <- rep(NA,6)
for(i in 1:nrow(netdis_mat_gst1$comp_spec)){
  ind1 <- netdis_mat_gst1$comp_spec[i,"index_a"]
  ind2 <- netdis_mat_gst1$comp_spec[i,"index_b"]
  mat_gst1[ind1,ind2] <- netdis_mat_gst1$netdis["netdis4",i]
  mat_gst1[ind2,ind1] <-  mat_gst1[ind1,ind2]
  #
  ind1 <- netdis_mat_gst2$comp_spec[i,"index_a"]
  ind2 <- netdis_mat_gst2$comp_spec[i,"index_b"]
  mat_gst2[ind1,ind2] <- netdis_mat_gst2$netdis["netdis4",i]
  mat_gst2[ind2,ind1] <- mat_gst2[ind1,ind2]
  #
  vnames[ind1] <- as.character(netdis_mat_gst1$comp_spec[i,"name_a"])
  vnames[ind2] <- as.character(netdis_mat_gst1$comp_spec[i,"name_b"])
}
rownames(mat_gst1) <- vnames
colnames(mat_gst1) <- vnames
rownames(mat_gst2) <- vnames
colnames(mat_gst2) <- vnames

#Network comparisons heatmap with Gold-Standard 1 
legend1 <- c(seq(min(mat_gst1),max(mat_gst1),length.out = 5))
levels1 <- round(legend1,digits = 2); levels1[length(levels1)]="Netdis"
pheatmap::pheatmap(mat = as.dist(mat_gst1),cluster_rows = TRUE,clustering_method = "average",angle_col=45,main = "Netdis GoldStd-1",treeheight_row = 80,labels_row = vnames,labels_col = vnames,display_numbers = TRUE,legend_breaks = legend1,legend_labels = levels1)

#Network comparisons heatmap with Gold-Standard 2
legend2 <- c(seq(min(mat_gst2),max(mat_gst2),length.out = 5))
levels2 <- round(legend2,digits = 2); levels2[length(levels2)]="Netdis"
pheatmap::pheatmap(mat = as.dist(mat_gst2),cluster_rows = TRUE,clustering_method = "average",angle_col=45,main = "Netdis GoldStd-1",treeheight_row = 80,labels_row = vnames,labels_col = vnames,display_numbers = TRUE,legend_breaks = legend2,legend_labels = levels2)
```


## Netdis-GP: Using a Geometric-Poisson approximation

This variant focuses on detecting more general and global discrepancies between the ego-network structures.

```{r, netdisGP}
# Netdis Geometric-Poisson comparisons
netdis_mat_gst1 <- netdis_many_to_many(graphs = glist, ref_graph = NULL)
netdis_mat_gst1
```

```{r,netdisGPPLOT,fig.align='center'}
# Creating matrices to plot the the comparison
mat_gst1 <- matrix(nrow=6,ncol=6,0)
vnames <- rep(NA,6)
for(i in 1:nrow(netdis_mat_gst1$comp_spec)){
  ind1 <- netdis_mat_gst1$comp_spec[i,"index_a"]
  ind2 <- netdis_mat_gst1$comp_spec[i,"index_b"]
  mat_gst1[ind1,ind2] <- netdis_mat_gst1$netdis["netdis4",i]
  mat_gst1[ind2,ind1] <-  mat_gst1[ind1,ind2]
  #
  vnames[ind1] <- as.character(netdis_mat_gst1$comp_spec[i,"name_a"])
  vnames[ind2] <- as.character(netdis_mat_gst1$comp_spec[i,"name_b"])
}
rownames(mat_gst1) <- vnames
colnames(mat_gst1) <- vnames

#Network comparisons heatmap with Gold-Standard 1 
legend1 <- c(seq(min(mat_gst1),max(mat_gst1),length.out = 5))
levels1 <- round(legend1,digits = 2); levels1[length(levels1)]="Netdis-GP"
pheatmap::pheatmap(mat = as.dist(mat_gst1),cluster_rows = TRUE,clustering_method = "average",angle_col=45,main = "Netdis GoldStd-1",treeheight_row = 80,labels_row = vnames,labels_col = vnames,display_numbers = TRUE,legend_breaks = legend1,legend_labels = levels1)
```

## Using Netdis with no expectation ($E_w=0$)
Comparing the networks via their observed ego counts without centering them, (equivalent to using expectation equal to zero). This variant thus focuses on detecting small discrepancies between the networks.


```{r,netdiszero}
# Set source directory for Virus protein-protein interaction edge files stored in the netdist package.
source_dir <- system.file(file.path("extdata", "VRPINS"), package = "netdist")

# Load query graphs as igraph objects
graph_1 <- read_simple_graph(file.path(source_dir, "EBV.txt"),format = "ncol")
graph_2 <- read_simple_graph(file.path(source_dir, "ECL.txt"),format = "ncol")

#Netdis using no expectations (or equivalently, expectation equal to zero).
netdis_one_to_one(graph_1= graph_1, graph_2= graph_2,  ref_graph = 0)

# Providing pre-calculated subgraph counts.
props_1 <- count_graphlets_ego(graph = graph_1)
props_2 <- count_graphlets_ego(graph = graph_2)

netdis_one_to_one(graphlet_counts_1= props_1,graphlet_counts_2= props_2, ref_graph = 0)  
```

-------------------------


# Bibliography

* W. Ali, T. Rito, G. Reinert, F. Sun, and C. M. Deane. Alignment-free protein interaction network comparison. Bioinformatics, 30:i430–i437, 2014.

* L. Ospina-Forero, C. M. Deane, and G. Reinert. Assessment of model fit via network comparison methods based on subgraph counts. Journal of Complex Networks, page cny017, August 2018.

* A. E. Wegner, L. Ospina-Forero, R. E. Gaunt, C. M. Deane, and G. Reinert. Identifying networks with common organizational principles. Journal of Complex networks, 2017.

* F. Picard, J.-J. Daudin, M. Koskas, S. Schbath, and S. Robin. Assessing the exceptionality of network motifs. Journal of Computational Biology, 15(1):1–20, 2008.