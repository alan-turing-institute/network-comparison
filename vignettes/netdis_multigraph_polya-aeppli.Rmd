---
title: "Netdis - Multiple graphs with Expected Counts from Geometric Poisson Approximation"
author: "Martin O'Reilly, Jack Roberts"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Netdis - multiple graphs with GP Approximation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Load required libraries
```{r}
# Load libraries
library("netdist")
library("purrr")
```

## Load graphs
```{r}
# Set source directory for Virus PPI graph edge files
source_dir <- system.file(file.path("extdata", "VRPINS"), package = "netdist")

# Load query graphs
graphs <- read_simple_graphs(source_dir, format = "ncol", pattern = "*")
```

## Set Netdis parameters
```{r}
# Maximum graphlet size to calculate counts and netdis statistic for.
max_graphlet_size <- 4

# Ego network neighbourhood size
neighbourhood_size <- 2

# Minimum size of ego networks to consider
min_ego_nodes <- 3
min_ego_edges <- 1

# Ego network density binning parameters
min_bin_count <- 5
num_bins <- 100
```

## Generate ego networks
```{r}
# Get ego networks for query graphs
ego_networks <- purrr::map(
  graphs, make_named_ego_graph,
  order = neighbourhood_size, 
  min_ego_nodes = min_ego_nodes, 
  min_ego_edges = min_ego_edges
)
```

## Count graphlets in ego networks
```{r}
# Count graphlets for ego networks in query graphs
graphlet_counts <- purrr::map(
  ego_networks,
  ego_to_graphlet_counts,
  max_graphlet_size = max_graphlet_size
)
```

## Bin ego networks by density
```{r}

# Get ego-network densities
densities <- purrr::map(ego_networks,
                        ego_network_density)

binning_fn = purrr::partial(binned_densities_adaptive,
                            min_counts_per_interval = 5,
                            num_intervals = 100)
# Adaptively bin ego-network densities
binned_densities <- purrr::map(densities,
                               binning_fn)

ego_density_bins <- purrr::map(binned_densities, function(x) {x$breaks})
ego_density_bin_indexes <- purrr::map(binned_densities, function(x) {x$interval_indexes})

```

## Calculate expected graphlet counts in each bin using geometric poisson approximation
```{r}

density_binned_counts_gp <- function(graphlet_counts, bin_indexes, max_graphlet_size) {
  
  mean_binned_graphlet_counts <- mean_density_binned_graphlet_counts(
                                  graphlet_counts, 
                                  bin_indexes)
  
  exp_counts_bin <- function(bin_idx) {
    counts <- graphlet_counts[bin_indexes == bin_idx, ]
    means <- mean_binned_graphlet_counts[bin_idx,]
    
    mean_sub_counts <- sweep(counts, 2, means)
    
    Vd_sq <- colSums(mean_sub_counts^2)/(nrow(mean_sub_counts)-1)
    theta_d <- 2*means / (Vd_sq + means)

    exp_counts_dk <- vector()
    for (k in 2:max_graphlet_size) {
      graphlet_idx <- graphlet_ids_for_size(k)
      
      lambda_dk <- (1 / length(graphlet_idx)) * 
                   sum(
                     2 * means[graphlet_idx]^2 /
                     (Vd_sq[graphlet_idx] + means[graphlet_idx])
                   )
      
      exp_counts_dk <- append(exp_counts_dk,
                              lambda_dk / theta_d[graphlet_idx])
    }
    
    exp_counts_dk
  }
  
  nbins <- length(unique(bin_indexes))
  expected_counts_bin <- t(mapply(exp_counts_bin, bin_idx = 1:nbins))
  
  # deal with NAs caused by bins with zero counts for a graphlet
  expected_counts_bin[is.nan(expected_counts_bin)] = 0
  
  expected_counts_bin
}


bin_counts_fn <- purrr::partial(density_binned_counts_gp,
                               max_graphlet_size = max_graphlet_size)

binned_graphlet_counts <- mapply(bin_counts_fn,
                                 graphlet_counts,
                                 ego_density_bin_indexes)
```

## Centre graphlet counts of query graphs using binned expected counts 
```{r}
# Calculate expected graphlet counts for each ego network
exp_counts_fn <- purrr::partial(netdis_expected_graphlet_counts_per_ego,
                               max_graphlet_size = max_graphlet_size,
                               scale_fn=NULL)

exp_graphlet_counts <- mapply(exp_counts_fn,
                              ego_networks,
                              ego_density_bins,
                              binned_graphlet_counts)



# Centre graphlet counts by subtracting expected counts
centred_graphlet_counts <-  mapply("-", graphlet_counts, exp_graphlet_counts)

```

## Sum centred graphlet counts across all ego networks
```{r}
sum_graphlet_counts <- lapply(centred_graphlet_counts, colSums)
```

## Calculate netdis statistics
```{r}

# Generate pairwise comparisons
comp_spec <- cross_comparison_spec(sum_graphlet_counts, how = "many-to-many")

## ------------------------------------------------------------------------
# Calculate netdis statistics
results <- parallel::mcmapply(
    function(index_a, index_b) {
      netdis_uptok(
        sum_graphlet_counts[[index_a]], 
        sum_graphlet_counts[[index_b]],
        max_graphlet_size = max_graphlet_size
      )
    },
    comp_spec$index_a,
    comp_spec$index_b,
    SIMPLIFY = TRUE)
  
  
list(netdis = results, comp_spec = comp_spec)
```